---
title: "Milestone 5"
author: "Benjamin Hoffner-Brodsky"
date: "4/18/2020"
bibliography: bibliography.bib
output: bookdown::pdf_document2
#keep_tex: TRUE
link_citations: TRUE
biblio-style: "apalike"
#nocite: '@*'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(sandwich)
library(lmtest)
library(xtable)

rm(list = ls())

setwd("..")

load("replication_files/devDTA.Rdata")

clusterSE <- function(model, data, cluster){

cluster_indices <- model %>% 
  model.matrix() %>% 
  row.names %>% 
  as.numeric()
  
cluster <- data[cluster_indices, cluster] %>% 
  as.factor()

M <- cluster %>%  
  unique() %>% 
  length()
  
N <- length(cluster)

K <- model$rank

dfc <- (M / (M-1)) * ((N-1) / (N-K))

u.clust <- apply(estfun(model), 2, function(x) tapply(x, cluster, sum))

cl.vcov <- dfc * sandwich(model, meat = crossprod(u.clust) / N)

return(cl.vcov)
}

outcomeindex <- c(35, 60, 52, 58, 64, 68, 72, 76, 63, 53, 59, 67, 71, 75, 79)

mymatrix <- matrix(nrow = length(outcomeindex), ncol = 4)

# Regression for loop begins 

# Iterates over each outcome variable in outcomeindex

for(i in 1:length(outcomeindex)){
  
# Subsets devDTA to only those observations for which the outcome variable of
# interest and the constituency type (Scheduled Caste or General) is known to
# prepare for regressing the outcome variable on the constituency type below
  
devDTAer <- devDTA[complete.cases(devDTA[, outcomeindex[i]], devDTA$AC_type_noST), ]

# Calculates the mean of the outcome variable of interest for each of the
# Scheduled Caste subset and the General Caste subset, respectivelty, rounded to
# 1 decimal, and outputs the General mean into the first column and Scheduled
# Caste mean into the second column of mymatrix

mymatrix[i, c(1,2)] <- tapply(devDTAer[, outcomeindex[i]], devDTAer$AC_type_noST, 
                                 mean, na.rm = T) %>% 
  round(1)

# Regresses the outome variable of interest on the type of constituency using a
# linear model

myOLS <- lm(devDTAer[, outcomeindex[i]] ~ devDTAer$AC_type_noST)

# Rounds the coefficient of constituency type on the outcome variable of
# interest to 1 decimal, and outputs into the third column of mymatrix

mymatrix[i, c(3)] <- round(myOLS$coef[2], 1)

# Calculates the p-value using state-level clustered standard errors from
# clusterSE(), estimated separately for each outcome variable, and outputs into
# the fourth column of mymatrix after rounding to 2 decimals. If the p-value is
# less than 0.01, then "<0.01" is outputted instead

mySE <- clusterSE(myOLS, data = devDTAer, cluster = "State_no_2001_old")

mymatrix[i, c(4)] <- ifelse(coeftest(myOLS, mySE)[2,4] < 0.01, "<0.01", 	
                         round(coeftest(myOLS, mySE)[2, 4] ,2))

# Regression for loop ends
}

# Renames the rows to the name of the outcome variable of interest

row.names(mymatrix) <- names(devDTA[outcomeindex])

# Renames the columns to the names of the statistics being generated. As the
# model estimated was a binary explanatory linear model, the coefficient of
# constituency type on the outcome variable of interest can similarly be
# interpreted as the difference between the means of the two samples

colnames(mymatrix) <- c("Mean general", "Mean reserved", "Difference", "P-value")

# Renames the rows again, this time to more readable interpretations of the
# outcome variables of interest. There's no reason to rename twice; the first
# rename was presumably an intermediary step to more easily determine the order
# of rownames

row.names(mymatrix) <- c("Percentage of SCs", "Literacy rate", " Employment Rate", 
                       "Agricultural laborers", "Electricity in village", 
                       "School in village ","Medical facility in village",
                       "Comm. channel in village", "Literacy gap", " Employment gap", 
                       "Agricultural laborers gap", "Electricity in village gap", 
                       "School in village gap","Medical facility in village gap",
                       "Comm. channel in village gap")
```

# Overview 

This project is a replication for GOV 1006 at Harvard under Preceptor David Kane^[All analysis for this replication is available at [Development without Representation Replication Repo](https://github.com/ben-hb/development_without_representation_replication)].

All [data and replication materials](https://www.openicpsr.org/openicpsr/project/113613/version/V1/view) were kindly made public by [Francesca R. Jensenius](https://www.francesca.no), Professor of Political Science at the University of Oslo and Senior Research Fellow at the Norwegian Institute of International Affairs. 

Since 1950, the Indian Parliament and India's state assemblies have guaranteed a minimum number of seats to Scheduled Castes (SCs). Ensuring ascriptive representation for the 16% of Indian citizens who belong to SCs was intended, in part, as a mechanism to equitably allocate resources along caste lines. To implement SC quotas, the federal government non-randomly selected constituencies in which only SC members can run for office, though all members of the constituency are allowed to vote. 

The paper uses a dataset of constituency-level data of 3,134 state assembly constituencies from the 15 largest Indian states to compare development levels across reserved and non-reserved constituencies in 1971 and 2001. As reserved constituencies were non-randomly determined, Jensenius forms pairs of reserved and non-reserved constituencies, matching based on pre-selection characteristics to mitigate the effect of selection bias. She finds a null constituency-level effect on overall development, redistribution to SCs, literacy rates, SC employment patterns, and village amenities. 

Development from Representation appeared in the *American Economic Journal: Applied Economics*,  vol 7, no. 3 pp. 196â€“220. 

# Beautiful Graphic

```{r table_1, results = "asis"}

# Outputs the regression table, aligning the names of outcome variables left and
# the summary statistics right

xtable(mymatrix, align = c("l", "r", "r", "r", "r"), 
       caption = "Difference in general and SC-reserved constituencies in 2001")

```

```{r graph_1}

# Instructing R to attach devDTA to the R search path so that variables within
# devDTA can be referenced solely by the column name

attach(devDTA)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Caste and
# live in a General constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot_gen <- mean(Plit71_nonSC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen", "gen"))

names(myplot_gen) <- c("y", "x", "group")
# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Cast and live
# in a Scheduled Cast quota constituency and second row equal to the mean of the
# literacy rate under the same consteaints but measured in 2001

myplot_sc <- mean(Plit71_nonSC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc", "sc"))

names(myplot_sc) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a General constituency and second row equal to the mean of the literacy rate
# under the same constraints but measured in 2001

myplot2_gen <- mean(Plit71_SC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen2", "gen2"))

names(myplot2_gen) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a Scheduled Caste quote constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot2_sc <- mean(Plit71_SC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc2", "sc2"))

names(myplot2_sc) <- names(myplot_gen)

myplot <- rbind(myplot_gen, myplot_sc) 

myplot2 <- rbind(myplot2_gen, myplot2_sc)

# Prepare dataframe for plotting arrows showing general change

x_gen <- 1971 + 0.02 
x_sc <- 2001 - 0.02

y0_gen <- myplot_gen[1, 1] + 2
y1_gen <- myplot_gen[2, 1] - 2

y0_sc <- myplot_sc[1, 1] + 2
y1_sc <- myplot_sc[2, 1] - 2 

myplot_arrows <- data.frame(x = c(x_gen, x_gen, x_sc, x_sc), 
                            y = c(y0_gen, y1_gen, y0_sc, y1_sc),
                            group = c("gen", "gen", "sc", "sc"))

# Same for myplot2

x_gen_2 <- 1971 + 0.02 
x_sc_2 <- 2001 - 0.02

y0_gen_2 <- myplot2_gen[1, 1] + 2
y1_gen_2 <- myplot2_gen[2, 1] - 2

y0_sc_2 <- myplot2_sc[1, 1] + 2
y1_sc_2 <- myplot2_sc[2, 1] - 2 

myplot2_arrows <- data.frame(x = c(x_gen_2, x_gen_2, x_sc_2, x_sc_2), 
                            y = c(y0_gen_2, y1_gen_2, y0_sc_2, y1_sc_2),
                            group = c("gen", "gen", "sc", "sc"))

# Plotting Non-SC Population

ggplot(myplot, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red"), 
                     labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) +
  scale_linetype_manual(values = c("dashed", "solid"), 
                        labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0)) +
  labs(
    title = "Non-SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot_gen[2, 1] - myplot_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot_sc[2, 1] - myplot_sc[1, 1], 2)))

# Plotting SC Population

ggplot(myplot2, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red")) +
  scale_linetype_manual(values = c("dashed", "solid")) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        
# Removing the legend from the second plot, in line with Jensenius' choice,
# because the legend is identical from the prior graph

        legend.position = "none") +
  labs(
    title = "SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  
# In-line with Jensenius, I opt to only present the tick marks for the years the
# data represents, to avoid readers interpreting the graph as commenting on the
# period between 1971 and 2001
  
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot2_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot2_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot2_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot2_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot2_gen[2, 1] - myplot2_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot2_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot2_sc[2, 1] - myplot2_sc[1, 1], 2)))

```

# Appendix 

```{r table_replication}

# Replicating "Table 1: Difference in general and SC-reserved constituencies in
# 2001" from page 22

# First, I replicate this by using Jensenius' exact code and standard error
# clustering algorithm





```


# References