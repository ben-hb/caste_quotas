---
title: "Development without Representation: Replication"
author: "Benjamin Hoffner-Brodsky"
date: "5/15/2020"
bibliography: bibliography.bib
output: bookdown::pdf_document2
link_citations: TRUE
biblio-style: "apalike"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(sandwich)
library(lmtest)
library(xtable)

rm(list = ls())

load("replication_files/devDTA.Rdata")

clusterSE <- function(model, data, cluster){

cluster_indices <- model %>% 
  model.matrix() %>% 
  row.names %>% 
  as.numeric()
  
cluster <- data[cluster_indices, cluster] %>% 
  as.factor()

M <- cluster %>%  
  unique() %>% 
  length()
  
N <- length(cluster)

K <- model$rank

dfc <- (M / (M-1)) * ((N-1) / (N-K))

u.clust <- apply(estfun(model), 2, function(x) tapply(x, cluster, sum))

cl.vcov <- dfc * sandwich(model, meat = crossprod(u.clust) / N)

return(cl.vcov)
}

outcomeindex <- c(35, 60, 52, 58, 64, 68, 72, 76, 63, 53, 59, 67, 71, 75, 79)

mymatrix <- matrix(nrow = length(outcomeindex), ncol = 4)

# Regression for loop begins 

# Iterates over each outcome variable in outcomeindex

for(i in 1:length(outcomeindex)){
  
# Subsets devDTA to only those observations for which the outcome variable of
# interest and the constituency type (Scheduled Caste or General) is known to
# prepare for regressing the outcome variable on the constituency type below
  
devDTAer <- devDTA[complete.cases(devDTA[, outcomeindex[i]], devDTA$AC_type_noST), ]

# Calculates the mean of the outcome variable of interest for each of the
# Scheduled Caste subset and the General Caste subset, respectivelty, rounded to
# 1 decimal, and outputs the General mean into the first column and Scheduled
# Caste mean into the second column of mymatrix

mymatrix[i, c(1,2)] <- tapply(devDTAer[, outcomeindex[i]], devDTAer$AC_type_noST, 
                                 mean, na.rm = T) %>% 
  round(1)

# Regresses the outome variable of interest on the type of constituency using a
# linear model

myOLS <- lm(devDTAer[, outcomeindex[i]] ~ devDTAer$AC_type_noST)

# Rounds the coefficient of constituency type on the outcome variable of
# interest to 1 decimal, and outputs into the third column of mymatrix

mymatrix[i, c(3)] <- round(myOLS$coef[2], 1)

# Calculates the p-value using state-level clustered standard errors from
# clusterSE(), estimated separately for each outcome variable, and outputs into
# the fourth column of mymatrix after rounding to 2 decimals. If the p-value is
# less than 0.01, then "<0.01" is outputted instead

mySE <- clusterSE(myOLS, data = devDTAer, cluster = "State_no_2001_old")

mymatrix[i, c(4)] <- ifelse(coeftest(myOLS, mySE)[2,4] < 0.01, "<0.01", 	
                         round(coeftest(myOLS, mySE)[2, 4] ,2))

# Regression for loop ends
}

# Renames the rows to the name of the outcome variable of interest

row.names(mymatrix) <- names(devDTA[outcomeindex])

# Renames the columns to the names of the statistics being generated. As the
# model estimated was a binary explanatory linear model, the coefficient of
# constituency type on the outcome variable of interest can similarly be
# interpreted as the difference between the means of the two samples

colnames(mymatrix) <- c("Mean general", "Mean reserved", "Difference", "P-value")

# Renames the rows again, this time to more readable interpretations of the
# outcome variables of interest. There's no reason to rename twice; the first
# rename was presumably an intermediary step to more easily determine the order
# of rownames

row.names(mymatrix) <- c("Percentage of SCs", "Literacy rate", " Employment Rate", 
                       "Agricultural laborers", "Electricity in village", 
                       "School in village ","Medical facility in village",
                       "Comm. channel in village", "Literacy gap", " Employment gap", 
                       "Agricultural laborers gap", "Electricity in village gap", 
                       "School in village gap","Medical facility in village gap",
                       "Comm. channel in village gap")
```

# Overview 

This project is a replication for GOV 1006 at Harvard under Preceptor David Kane^[All analysis for this replication is available at [Development without Representation Replication Repo](https://github.com/ben-hb/development_without_representation_replication)].

All [data and replication materials](https://www.openicpsr.org/openicpsr/project/113613/version/V1/view) were kindly made public by [Francesca R. Jensenius](https://www.francesca.no), Professor of Political Science at the University of Oslo and Senior Research Fellow at the Norwegian Institute of International Affairs. 

Since 1950, the Indian Parliament and India's state assemblies have guaranteed a minimum number of seats to Scheduled Castes (SCs). Ensuring ascriptive representation for the 16% of Indian citizens who belong to SCs was intended, in part, as a mechanism to equitably allocate resources along caste lines. To implement SC quotas, the federal government non-randomly selected constituencies in which only SC members can run for office, though all members of the constituency are allowed to vote. 

The paper uses a dataset of constituency-level data of 3,134 state assembly constituencies from the 15 largest Indian states to compare development levels across reserved and non-reserved constituencies in 1971 and 2001. As reserved constituencies were non-randomly determined, Jensenius forms pairs of reserved and non-reserved constituencies, matching based on pre-selection characteristics to mitigate the effect of selection bias. She finds a null constituency-level effect on overall development, redistribution to SCs, literacy rates, SC employment patterns, and village amenities. 

Development from Representation appeared in the *American Economic Journal: Applied Economics*,  vol 7, no. 3 pp. 196â€“220. 

# Beautiful Graphic

```{r table_1, results = "asis"}

# Outputs the regression table, aligning the names of outcome variables left and
# the summary statistics right

xtable(mymatrix, align = c("l", "r", "r", "r", "r"), 
       caption = "Difference in general and SC-reserved constituencies in 2001")

```

```{r graph_1}

# Instructing R to attach devDTA to the R search path so that variables within
# devDTA can be referenced solely by the column name

attach(devDTA)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Caste and
# live in a General constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot_gen <- mean(Plit71_nonSC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen", "gen"))

names(myplot_gen) <- c("y", "x", "group")
# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Cast and live
# in a Scheduled Cast quota constituency and second row equal to the mean of the
# literacy rate under the same consteaints but measured in 2001

myplot_sc <- mean(Plit71_nonSC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc", "sc"))

names(myplot_sc) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a General constituency and second row equal to the mean of the literacy rate
# under the same constraints but measured in 2001

myplot2_gen <- mean(Plit71_SC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen2", "gen2"))

names(myplot2_gen) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a Scheduled Caste quote constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot2_sc <- mean(Plit71_SC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc2", "sc2"))

names(myplot2_sc) <- names(myplot_gen)

myplot <- rbind(myplot_gen, myplot_sc) 

myplot2 <- rbind(myplot2_gen, myplot2_sc)

# Prepare dataframe for plotting arrows showing general change

x_gen <- 1971 + 0.02 
x_sc <- 2001 - 0.02

y0_gen <- myplot_gen[1, 1] + 2
y1_gen <- myplot_gen[2, 1] - 2

y0_sc <- myplot_sc[1, 1] + 2
y1_sc <- myplot_sc[2, 1] - 2 

myplot_arrows <- data.frame(x = c(x_gen, x_gen, x_sc, x_sc), 
                            y = c(y0_gen, y1_gen, y0_sc, y1_sc),
                            group = c("gen", "gen", "sc", "sc"))

# Same for myplot2

x_gen_2 <- 1971 + 0.02 
x_sc_2 <- 2001 - 0.02

y0_gen_2 <- myplot2_gen[1, 1] + 2
y1_gen_2 <- myplot2_gen[2, 1] - 2

y0_sc_2 <- myplot2_sc[1, 1] + 2
y1_sc_2 <- myplot2_sc[2, 1] - 2 

myplot2_arrows <- data.frame(x = c(x_gen_2, x_gen_2, x_sc_2, x_sc_2), 
                            y = c(y0_gen_2, y1_gen_2, y0_sc_2, y1_sc_2),
                            group = c("gen", "gen", "sc", "sc"))

# Plotting Non-SC Population

ggplot(myplot, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red"), 
                     labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) +
  scale_linetype_manual(values = c("dashed", "solid"), 
                        labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0)) +
  labs(
    title = "Non-SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot_gen[2, 1] - myplot_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot_sc[2, 1] - myplot_sc[1, 1], 2)))

# Plotting SC Population

ggplot(myplot2, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red")) +
  scale_linetype_manual(values = c("dashed", "solid")) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        
# Removing the legend from the second plot, in line with Jensenius' choice,
# because the legend is identical from the prior graph

        legend.position = "none") +
  labs(
    title = "SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  
# In-line with Jensenius, I opt to only present the tick marks for the years the
# data represents, to avoid readers interpreting the graph as commenting on the
# period between 1971 and 2001
  
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot2_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot2_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot2_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot2_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot2_gen[2, 1] - myplot2_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot2_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot2_sc[2, 1] - myplot2_sc[1, 1], 2)))

```

```{r matching_models, include = FALSE}


# Creates a generalizable function to output evaluation of matches

balanceTable <- function(covariates, bal.out){

  cat("\\begin{table}[ht] \n")
  cat("\\caption{Difference in means for treated and control and Balance output from matches} \n")
  cat(" \\begin{tabular}{lrrcrr} \\hline \\hline \n")
  cat("Covariate	&\\multicolumn{2}{c}{Before matching}",
    "&&\\multicolumn{2}{c}{After matching}", "\\", "\\", "\\cline{2-3} \\cline{5-6} \n", sep = "")
  cat("& \\emph{t p}-value &KS \\emph{p}-value &&",
    "\\emph{t p}-value &KS \\emph{p}-value", "\\", "\\", "\n", sep = "")
  
  z <- sapply(1:dim(covariates)[2], function(x){
    cat(names(covariates)[x], "&",
    round(bal.out$BeforeMatching[[x]]$tt$p.value,2), "&",
    ifelse(is.null(bal.out$BeforeMatching[[x]]$ks$ks.boot.pvalue) == 0,
      round(bal.out$BeforeMatching[[x]]$ks$ks.boot.pvalue,2), "---"), "&&",
    round(bal.out$AfterMatching[[x]]$tt$p.value,2), "&",
    ifelse(is.null(bal.out$AfterMatching[[x]]$ks$ks.boot.pvalue) == 0,
      round(bal.out$AfterMatching[[x]]$ks$ks.boot.pvalue,2), "---"), "\\", "\\", "\n",
      sep = "")
  })
  cat("\\end{tabular} \\end{table} \n")
  }

# Detaches devDTA from the R search path on first run and matchdta on second run
  
detach()
  
# Subsets devDTA to just the observations for which all of the following values
# are known: the percentage of Scheduled Caste individuals in 1971, the state an
# assembly constituency belonged to in 2001, the constituencty type of the
# assembly constituency not including Scheduled Tribes from 1974-2000, the
# Scheduled Caste literacy rate in 1971, and the Scheduled Caste literacy rate
# in 2001

matchdta <- devDTA %>% 
  filter(!is.na(devDTA$SC_percent71_true), 
         !is.na(devDTA$State_no_2001_old), 
         !is.na(devDTA$AC_type_noST),
         !is.na(devDTA$Plit71_SC), 
         !is.na(devDTA$Plit_SC))

# I haven't yet figured out what this is doing. From what I can tell,
# matchdta$SC_percent71_true is already a numeric value, so there's likely some
# nuance I'm missing here

# matchdta$SC_percent71_true <- as.numeric(as.character(matchdta$SC_percent71_true))

# Attaches matchdta to the default R search path 

attach(matchdta)

# Generates a numeric variable which returns 1 if the Assembly Constituency is a
# Scheduled Caste Constituency and 0 otherwise

Tr <- ifelse(AC_type_noST == "SC", 1, 0)

# Generates a new data frame composed of the following variables from matchdta:
# the state an assembly constituency belonged to in 2001, the number of the
# district an Assembly Constituency was in accoring to the 1976 Delimitation
# report, the number of the Parliamentary Constituency an Assembly Constituency
# was part of from 1974-2000, and the percentage of Scheduled Caste individuals
# in 1971

X <- as.data.frame(cbind(as.numeric(State_no_2001_old), 
                         as.numeric(DELIM_district_no), 
                         as.numeric(PC_no_1976), 
                         SC_percent71_true))

# Strict Matching

# Estimates the average treatment effect with literacy rate as the outcome
# variable being matched on the explanatory variables in X for the treatments in
# Tr, which does exact matching for all explanatory variables except for the
# percentage of Scheduled Caste individuals in 1971

# This is done using a multivariate and propensity score matching estimator

Matched_norep1 <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT", 
                       exact = c(TRUE, TRUE, TRUE, FALSE), 
                     replace = FALSE)


bal_SC_norep1 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep1, nboots = 1000, 
                            data = matchdta)

bal.out_norep1 <- Matching::MatchBalance(Tr ~ Pop_tot1971 + P_ST71 + Plit71_nonSC + Plit71_SC + 
                                P_W71_nonSC + P_W71_SC + P_al71_nonSC + P_al71_SC, 
                              match.out=Matched_norep1, nboots = 1000, data = matchdta)

covariates1 <- cbind(Pop_tot1971, P_ST71, Plit71_nonSC, Plit71_SC, P_W71_nonSC, 
                                  P_W71_SC, P_al71_nonSC, P_al71_SC) %>% 
  as.data.frame()

names(covariates1) <- c("Population size", "Percentage of STs", "Literacy rate (non-SCs)", 
                     "Literacy rate (SCs)", "Employment (non-SCs)", "Employment (SCs)", 
                     "Agricultural laborers (non-SCs)", "Agricultural laborers (SCs)")

# Caliper Matching

Matched_norep2 <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT", 
                       exact = c(TRUE, TRUE, TRUE, FALSE), 
                     replace = FALSE, caliper = c(0, 0, 0, .5))

bal_SC_norep2 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep2, nboots = 1000, 
                            data = matchdta)

bal.out_norep2 <- Matching::MatchBalance(Tr ~ Pop_tot1971 + P_ST71 + Plit71_nonSC + Plit71_SC + 
                                P_W71_nonSC + P_W71_SC + P_al71_nonSC + P_al71_SC, 
                              match.out = Matched_norep2, nboots = 1000, data = matchdta)

covariates2 <- cbind(Pop_tot1971, P_ST71, Plit71_nonSC, Plit71_SC, P_W71_nonSC, 
                                  P_W71_SC, P_al71_nonSC, P_al71_SC) %>% 
  as.data.frame()

names(covariates2) <- c("Population size", "Percentage of STs", "Literacy rate (non-SCs)", 
                     "Literacy rate (SCs)", "Employment (non-SCs)", "Employment (SCs)", 
                     "Agricultural laborers (non-SCs)", "Agricultural laborers (SCs)")








# Initiate model matching for loop

for (i in 1:2) {

# Only runs the first iteration of the loop

if (i == 1) {

# Estimates the average treatment effect with literacy rate as the outcome
# variable being matched on the explanatory variables in X for the treatments in
# Tr, which does exact matching for all explanatory variables except for the
# percentage of Scheduled Caste individuals in 1971

# This is done using a multivariate and propensity score matching estimator

Matched_norep <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT",
                       exact = c(TRUE, TRUE, TRUE, FALSE),
                     replace = FALSE)

# Only runs the second iteration of the loop

} else if (i == 2) {

# Runs the same estimation as for i==1 except with specified calipers, or
# acceptable distances for matching, to specify a tolerance of 0.5 stanard
# deviations for the percentage of Scheduled Caste individuals in 1971

Matched_norep <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT",
                       exact = c(TRUE, TRUE, TRUE, FALSE),
                     replace = FALSE, caliper = c(0, 0, 0, .5))
}

# Each of these evaluate whether or not the match was successful in achieving
# balance on the observed covariates

if (i == 1) {

bal_SC_norep1 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep, nboots = 1000,
                            data = matchdta)

}

else if (i == 2) {

bal_SC_norep2 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep, nboots = 1000,
                            data = matchdta)

}

# Evaluates whether or not the match was successful using a wider array of
# covariates than before

bal.out_norep <- Matching::MatchBalance(Tr ~ Pop_tot1971 + P_ST71 + Plit71_nonSC + Plit71_SC +
                                P_W71_nonSC + P_W71_SC + P_al71_nonSC + P_al71_SC,
                              match.out=Matched_norep, nboots = 1000, data = matchdta)

# Prepares covariates for professional output

covariates <- cbind(Pop_tot1971, P_ST71, Plit71_nonSC, Plit71_SC, P_W71_nonSC,
                                  P_W71_SC, P_al71_nonSC, P_al71_SC) %>%
  as.data.frame()

names(covariates) <- c("Population size", "Percentage of STs", "Literacy rate (non-SCs)",
                     "Literacy rate (SCs)", "Employment (non-SCs)", "Employment (SCs)",
                     "Agricultural laborers (non-SCs)", "Agricultural laborers (SCs)")

if (i == 1) {
  balance_table_1 <- capture.output(balanceTable(covariates, bal.out_norep))
}

if (i == 2) {
  balance_table_2 <- capture.output(balanceTable(covariates, bal.out_norep))
}

# Pepares results from each loop iteration

##output

treatedDTA <- matchdta[Matched_norep$index.treated, ]
controlDTA <- matchdta[Matched_norep$index.control, ]
treatedDTA$index.match <- c(1:dim(treatedDTA)[1])
controlDTA$index.match <- c(1:dim(controlDTA)[1])

# Outputs final results of each loop iteration

if(i == 1){

matched1 <- rbind(treatedDTA, controlDTA)

} else {

matched2 <- rbind(treatedDTA, controlDTA)

}

# End model matching for loop

}
```

```{r out_balance_tables, results = "asis"}

balanceTable(covariates1, bal.out_norep1)
balanceTable(covariates2, bal.out_norep2)
```

# References