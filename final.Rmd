---
title: "Development without Representation: Replication"
author: "Benjamin Hoffner-Brodsky"
date: "5/15/2020"
bibliography: bibliography.bib
output: bookdown::pdf_document2
link_citations: TRUE
biblio-style: "apalike"
---

```{r table_1_setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

# Note: where possible variable names are preserved from Jensenius' published
# code to allow for easy methodological comparisons

# Each replicated output has 2 code chunks: one setup chunk, with include set to
# FALSE, and one output chunk, with include left to TRUE by default

library(tidyverse)
library(sandwich)
library(lmtest)
library(xtable)

rm(list = ls())

# Globally stopping xtable() from outputting a package watermark

options(xtable.comment = FALSE)

load("replication_files/devDTA.Rdata")

clusterSE <- function(model, data, cluster){

cluster_indices <- model %>% 
  model.matrix() %>% 
  row.names %>% 
  as.numeric()
  
cluster <- data[cluster_indices, cluster] %>% 
  as.factor()

M <- cluster %>%  
  unique() %>% 
  length()
  
N <- length(cluster)

K <- model$rank

dfc <- (M / (M-1)) * ((N-1) / (N-K))

u.clust <- apply(estfun(model), 2, function(x) tapply(x, cluster, sum))

cl.vcov <- dfc * sandwich(model, meat = crossprod(u.clust) / N)

return(cl.vcov)
}

outcomeindex <- c(35, 60, 52, 58, 64, 68, 72, 76, 63, 53, 59, 67, 71, 75, 79)

mymatrix <- matrix(nrow = length(outcomeindex), ncol = 4)

# Regression for loop begins 

# Iterates over each outcome variable in outcomeindex

for(i in 1:length(outcomeindex)){
  
# Subsets devDTA to only those observations for which the outcome variable of
# interest and the constituency type (Scheduled Caste or General) is known to
# prepare for regressing the outcome variable on the constituency type below
  
devDTAer <- devDTA[complete.cases(devDTA[, outcomeindex[i]], devDTA$AC_type_noST), ]

# Calculates the mean of the outcome variable of interest for each of the
# Scheduled Caste subset and the General Caste subset, respectivelty, rounded to
# 1 decimal, and outputs the General mean into the first column and Scheduled
# Caste mean into the second column of mymatrix

mymatrix[i, c(1,2)] <- tapply(devDTAer[, outcomeindex[i]], devDTAer$AC_type_noST, 
                                 mean, na.rm = T) %>% 
  round(1)

# Regresses the outome variable of interest on the type of constituency using a
# linear model

myOLS <- lm(devDTAer[, outcomeindex[i]] ~ devDTAer$AC_type_noST)

# Rounds the coefficient of constituency type on the outcome variable of
# interest to 1 decimal, and outputs into the third column of mymatrix

mymatrix[i, c(3)] <- round(myOLS$coef[2], 1)

# Calculates the p-value using state-level clustered standard errors from
# clusterSE(), estimated separately for each outcome variable, and outputs into
# the fourth column of mymatrix after rounding to 2 decimals. If the p-value is
# less than 0.01, then "<0.01" is outputted instead

mySE <- clusterSE(myOLS, data = devDTAer, cluster = "State_no_2001_old")

mymatrix[i, c(4)] <- ifelse(coeftest(myOLS, mySE)[2,4] < 0.01, "<0.01", 	
                         round(coeftest(myOLS, mySE)[2, 4] ,2))

# Regression for loop ends
}

# Renames the rows to the name of the outcome variable of interest

row.names(mymatrix) <- names(devDTA[outcomeindex])

# Renames the columns to the names of the statistics being generated. As the
# model estimated was a binary explanatory linear model, the coefficient of
# constituency type on the outcome variable of interest can similarly be
# interpreted as the difference between the means of the two samples

colnames(mymatrix) <- c("Mean general", "Mean reserved", "Difference", "P-value")

# Renames the rows again, this time to more readable interpretations of the
# outcome variables of interest. There's no reason to rename twice; the first
# rename was presumably an intermediary step to more easily determine the order
# of rownames

row.names(mymatrix) <- c("Percentage of SCs", "Literacy rate", " Employment Rate", 
                       "Agricultural laborers", "Electricity in village", 
                       "School in village ","Medical facility in village",
                       "Comm. channel in village", "Literacy gap", " Employment gap", 
                       "Agricultural laborers gap", "Electricity in village gap", 
                       "School in village gap","Medical facility in village gap",
                       "Comm. channel in village gap")
```

# Overview 

This project is a replication for GOV 1006 at Harvard under Preceptor David Kane^[All analysis for this replication is available at [Development without Representation Replication Repo](https://github.com/ben-hb/development_without_representation_replication)].

All [data and replication materials](https://www.openicpsr.org/openicpsr/project/113613/version/V1/view) were kindly made public by [Francesca R. Jensenius](https://www.francesca.no), Professor of Political Science at the University of Oslo and Senior Research Fellow at the Norwegian Institute of International Affairs. 

Since 1950, the Indian Parliament and India's state assemblies have guaranteed a minimum number of seats to Scheduled Castes (SCs). Ensuring ascriptive representation for the 16% of Indian citizens who belong to SCs was intended, in part, as a mechanism to equitably allocate resources along caste lines. To implement SC quotas, the federal government non-randomly selected constituencies in which only SC members can run for office, though all members of the constituency are allowed to vote. 

The paper uses a dataset of constituency-level data of 3,134 state assembly constituencies from the 15 largest Indian states to compare development levels across reserved and non-reserved constituencies in 1971 and 2001. As reserved constituencies were non-randomly determined, Jensenius forms pairs of reserved and non-reserved constituencies, matching based on pre-selection characteristics to mitigate the effect of selection bias. She finds a null constituency-level effect on overall development, redistribution to SCs, literacy rates, SC employment patterns, and village amenities. 

Development from Representation appeared in the *American Economic Journal: Applied Economics*,  vol 7, no. 3 pp. 196â€“220. 

# Beautiful Graphic

```{r table_1, results = "asis"}

# Outputs the regression table, aligning the names of outcome variables left and
# the summary statistics right

xtable(mymatrix, align = c("l", "r", "r", "r", "r"), 
       caption = "Difference in general and SC-reserved constituencies in 2001")

```

```{r figure_1}

# Instructing R to attach devDTA to the R search path so that variables within
# devDTA can be referenced solely by the column name

attach(devDTA)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Caste and
# live in a General constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot_gen <- mean(Plit71_nonSC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen", "gen"))

names(myplot_gen) <- c("y", "x", "group")
# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are not members of a Scheduled Cast and live
# in a Scheduled Cast quota constituency and second row equal to the mean of the
# literacy rate under the same consteaints but measured in 2001

myplot_sc <- mean(Plit71_nonSC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_nonSC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc", "sc"))

names(myplot_sc) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a General constituency and second row equal to the mean of the literacy rate
# under the same constraints but measured in 2001

myplot2_gen <- mean(Plit71_SC[AC_type_noST == "GEN"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "GEN"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("gen2", "gen2"))

names(myplot2_gen) <- names(myplot_gen)

# Generating a length 2 vector with first row equal to the mean of the 1971
# literacy rate for individuals who are members of a Scheduled Caste and live in
# a Scheduled Caste quote constituency and second row equal to the mean of the
# literacy rate under the same constraints but measured in 2001

myplot2_sc <- mean(Plit71_SC[AC_type_noST == "SC"], na.rm = T) %>% 
  rbind(mean(Plit_SC_7[AC_type_noST == "SC"], na.rm = T)) %>% 
  as.data.frame() %>% 
  cbind(c(1971, 2001)) %>% 
  cbind(c("sc2", "sc2"))

names(myplot2_sc) <- names(myplot_gen)

myplot <- rbind(myplot_gen, myplot_sc) 

myplot2 <- rbind(myplot2_gen, myplot2_sc)

# Prepare dataframe for plotting arrows showing general change

x_gen <- 1971 + 0.02 
x_sc <- 2001 - 0.02

y0_gen <- myplot_gen[1, 1] + 2
y1_gen <- myplot_gen[2, 1] - 2

y0_sc <- myplot_sc[1, 1] + 2
y1_sc <- myplot_sc[2, 1] - 2 

myplot_arrows <- data.frame(x = c(x_gen, x_gen, x_sc, x_sc), 
                            y = c(y0_gen, y1_gen, y0_sc, y1_sc),
                            group = c("gen", "gen", "sc", "sc"))

# Same for myplot2

x_gen_2 <- 1971 + 0.02 
x_sc_2 <- 2001 - 0.02

y0_gen_2 <- myplot2_gen[1, 1] + 2
y1_gen_2 <- myplot2_gen[2, 1] - 2

y0_sc_2 <- myplot2_sc[1, 1] + 2
y1_sc_2 <- myplot2_sc[2, 1] - 2 

myplot2_arrows <- data.frame(x = c(x_gen_2, x_gen_2, x_sc_2, x_sc_2), 
                            y = c(y0_gen_2, y1_gen_2, y0_sc_2, y1_sc_2),
                            group = c("gen", "gen", "sc", "sc"))

# Plotting Non-SC Population

ggplot(myplot, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red"), 
                     labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) +
  scale_linetype_manual(values = c("dashed", "solid"), 
                        labels = c(
    paste0("General (N = ", summary(devDTA$AC_type_noST)[1], ")"), 
    paste0("Reserved (N = ", summary(devDTA$AC_type_noST)[2], ")"))) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0)) +
  labs(
    title = "Non-SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot_gen[2, 1] - myplot_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot_sc[2, 1] - myplot_sc[1, 1], 2)))

# Plotting SC Population

ggplot(myplot2, aes(x = x, y = y, group = group)) + 
  geom_line(aes(linetype = group, color = group)) + 
  scale_color_manual(values = c("blue", "red")) +
  scale_linetype_manual(values = c("dashed", "solid")) + 
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        
# Removing the legend from the second plot, in line with Jensenius' choice,
# because the legend is identical from the prior graph

        legend.position = "none") +
  labs(
    title = "SC Population",
    x = "Year",
    y = "Literacy Rate"
  ) + 
  
# In-line with Jensenius, I opt to only present the tick marks for the years the
# data represents, to avoid readers interpreting the graph as commenting on the
# period between 1971 and 2001
  
  scale_x_continuous(breaks = c(1971, 2001)) + 
  scale_y_continuous(limits = c(10, 70),
                     breaks = c(10, 20, 30, 40, 50, 60, 70)) + 
  geom_hline(yintercept = myplot2_gen[2, 1], linetype = "dotted") +
  geom_hline(yintercept = myplot2_sc[1, 1], linetype = "dotted") +
  geom_line(data = myplot2_arrows, arrow = arrow(length = unit(0.15, "cm"), ends = "both", type = "closed")) +
  annotate("text", x = 1971 + 2, y = myplot2_gen[2, 1] - 8, 
           label = paste0("Change\ngeneral:\n", round(myplot2_gen[2, 1] - myplot2_gen[1, 1], 2))) + 
  annotate("text", x = 2001 - 2.5, y = myplot2_sc[1, 1] + 7,
           label = paste0("Change\nreserved:\n", round(myplot2_sc[2, 1] - myplot2_sc[1, 1], 2)))

```

```{r table_2_setup, include = FALSE}

# Detaches devDTA from the R search path
  
detach(devDTA)
  
# Subsets devDTA to just the observations for which all of the following values
# are known: the percentage of Scheduled Caste individuals in 1971, the state an
# assembly constituency belonged to in 2001, the constituencty type of the
# assembly constituency not including Scheduled Tribes from 1974-2000, the
# Scheduled Caste literacy rate in 1971, and the Scheduled Caste literacy rate
# in 2001

matchdta <- devDTA %>% 
  filter(!is.na(devDTA$SC_percent71_true), 
         !is.na(devDTA$State_no_2001_old), 
         !is.na(devDTA$AC_type_noST),
         !is.na(devDTA$Plit71_SC), 
         !is.na(devDTA$Plit_SC))

# I haven't yet figured out what this is doing. From what I can tell,
# matchdta$SC_percent71_true is already a numeric value, so there's likely some
# nuance I'm missing here

# matchdta$SC_percent71_true <- as.numeric(as.character(matchdta$SC_percent71_true))

# Attaches matchdta to the default R search path 

attach(matchdta)

# Generates a numeric variable which returns 1 if the Assembly Constituency is a
# Scheduled Caste Constituency and 0 otherwise

Tr <- ifelse(AC_type_noST == "SC", 1, 0)

# Generates a new data frame composed of the following variables from matchdta:
# the state an assembly constituency belonged to in 2001, the number of the
# district an Assembly Constituency was in accoring to the 1976 Delimitation
# report, the number of the Parliamentary Constituency an Assembly Constituency
# was part of from 1974-2000, and the percentage of Scheduled Caste individuals
# in 1971

X <- as.data.frame(cbind(as.numeric(State_no_2001_old), 
                         as.numeric(DELIM_district_no), 
                         as.numeric(PC_no_1976), 
                         SC_percent71_true))

# Strict Matching

# Estimates the average treatment effect with literacy rate as the outcome
# variable being matched on the explanatory variables in X for the treatments in
# Tr, which does exact matching for all explanatory variables except for the
# percentage of Scheduled Caste individuals in 1971

# This is done using a multivariate and propensity score matching estimator

Matched_norep1 <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT", 
                       exact = c(TRUE, TRUE, TRUE, FALSE), 
                     replace = FALSE)

# Evaluate whether or not the match was successful in achieving balance on the
# observed covariates

bal_SC_norep1 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep1, nboots = 1000, 
                            data = matchdta)

# Evaluates whether or not the match was successful using a wider array of
# covariates than before

bal.out_norep1 <- Matching::MatchBalance(Tr ~ Pop_tot1971 + P_ST71 + Plit71_nonSC + Plit71_SC + 
                                P_W71_nonSC + P_W71_SC + P_al71_nonSC + P_al71_SC, 
                              match.out=Matched_norep1, nboots = 1000, data = matchdta)

# Prepares covariates for professional output

covariates <- cbind(Pop_tot1971, P_ST71, Plit71_nonSC, Plit71_SC, P_W71_nonSC, 
                                  P_W71_SC, P_al71_nonSC, P_al71_SC) %>% 
  as.data.frame()

names(covariates) <- c("Population size", "Percentage of STs", "Literacy rate (non-SCs)", 
                     "Literacy rate (SCs)", "Employment (non-SCs)", "Employment (SCs)", 
                     "Agricultural laborers (non-SCs)", "Agricultural laborers (SCs)")

# Prepares results for future analysis 

treatedDTA1 <- matchdta[Matched_norep1$index.treated, ]
controlDTA1 <- matchdta[Matched_norep1$index.control, ]
treatedDTA1$index.match <- c(1:dim(treatedDTA1)[1])
controlDTA1$index.match <- c(1:dim(controlDTA1)[1])

matched1 <- rbind(treatedDTA1, controlDTA1)

# Caliper Matching

# Runs the same estimation as for Matched_norep1 except with specified calipers,
# or acceptable distances for matching, to specify a tolerance of 0.5 stanard
# deviations for the percentage of Scheduled Caste individuals in 1971

Matched_norep2 <- Matching::Match(Y = Plit, Tr = Tr, X = X, estimand = "ATT", 
                       exact = c(TRUE, TRUE, TRUE, FALSE), 
                     replace = FALSE, caliper = c(0, 0, 0, .5))

# Evaluate whether or not the match was successful in achieving balance on the
# observed covariates

bal_SC_norep2 <- Matching::MatchBalance(Tr ~ SC_percent71_true, match.out = Matched_norep2, nboots = 1000, 
                            data = matchdta)

# Evaluates whether or not the match was successful using a wider array of
# covariates than before

bal.out_norep2 <- Matching::MatchBalance(Tr ~ Pop_tot1971 + P_ST71 + Plit71_nonSC + Plit71_SC + 
                                P_W71_nonSC + P_W71_SC + P_al71_nonSC + P_al71_SC, 
                              match.out = Matched_norep2, nboots = 1000, data = matchdta)

# Prepares results for future analysis 

treatedDTA2 <- matchdta[Matched_norep2$index.treated, ]
controlDTA2 <- matchdta[Matched_norep2$index.control, ]
treatedDTA2$index.match <- c(1:dim(treatedDTA2)[1])
controlDTA2$index.match <- c(1:dim(controlDTA2)[1])

matched2 <- rbind(treatedDTA2, controlDTA2)

```

```{r table_2, results = "asis"}

# Outputs a table with the t and KS p-values before matching, after matching,
# and after matching with caliper

balanceTable2 <- function(covariates, bal.out1, bal.out2){

  cat("\\begin{table}[ht] \n")
  cat("\\caption{Difference in means for treated and control and Balance output from matches} \n")
  cat(" \\resizebox{\\textwidth}{!}{ \n \\begin{tabular}{lrrrrrr} \\hline \\hline \n")
  cat("Covariate	&\\multicolumn{2}{c}{Before matching}",
    "&\\multicolumn{2}{c}{After matching}", "&\\multicolumn{2}{c}{Matching (caliper)}", "\\", "\\", "\\cline{2-3} \\cline{4-5} \\cline{6-7} \n", sep = "")
  cat("& \\emph{t p}-value &KS \\emph{p}-value &",
    "\\emph{t p}-value &KS \\emph{p}-value &", "\\emph{t p}-value &KS \\emph{p}-value",
    "\\", "\\", "\n", sep = "")
  
  z <- sapply(1:dim(covariates)[2], function(x){
    cat(names(covariates)[x], "&",
    round(bal.out1$BeforeMatching[[x]]$tt$p.value,2), "&",
    ifelse(is.null(bal.out1$BeforeMatching[[x]]$ks$ks.boot.pvalue) == 0,
      round(bal.out1$BeforeMatching[[x]]$ks$ks.boot.pvalue,2), "---"), "&",
    round(bal.out1$AfterMatching[[x]]$tt$p.value,2), "&",
    ifelse(is.null(bal.out1$AfterMatching[[x]]$ks$ks.boot.pvalue) == 0,
      round(bal.out1$AfterMatching[[x]]$ks$ks.boot.pvalue,2), "---"), "&",
    round(bal.out2$AfterMatching[[x]]$tt$p.value,2), "&",
    ifelse(is.null(bal.out2$AfterMatching[[x]]$ks$ks.boot.pvalue) == 0,
      round(bal.out2$AfterMatching[[x]]$ks$ks.boot.pvalue,2), "---"), "\\", "\\", "\n",
      sep = "")
  })
  cat("\\end{tabular}} \\end{table} \n")
}

balanceTable2(covariates, bal.out_norep1, bal.out_norep2)

```

```{r figure_3}

detach(matchdta)

# Plots the distribution of the percentage of Scheduled Caste members in the
# constituency for both the General and Reserved Constituencies. The first plot
# shows hows this looks before matching, demonstrating that Reserved
# Constituencies tend to have a higher percentage of Scheduled Caste Community
# members than do General Constituencies. The second plot shows how this looks
# after matching, with the two distributions now being much closer but the
# Reserved Constituency distribution still being slightly to the right of the
# General Constituency distribution. The third plot shows this using matching
# with the more precise application of caliper, with a 0.5 standard deviation
# tolerance for matching, which now shows nearly identical distributions, though
# with a tiny right skew still remaining for Reserved Constituencies.

# Preparing to artificially generate legends, as the data is not sufficiently
# tidy to use aesthetic mappings

colors <- c("Reserved" = "red", "General" = "blue")

# First Plot: Before Matching

ggplot() + 
  geom_density(aes(x = devDTA$SC_percent71_true[devDTA$AC_type_noST == "SC" & 
                                                  complete.cases(devDTA$AC_type_noST)], 
                   color = "Reserved")) + 
  geom_density(aes(x = devDTA$SC_percent71_true[devDTA$AC_type_noST == "GEN" & 
                                         complete.cases(devDTA$AC_type_noST)],
                   color = "General"), linetype = "dashed") +
  scale_color_manual(values = colors,
                     labels = c(paste0("General (N=" , summary(matched2$AC_type_noST)[1], ")"),
                                paste0("Reserved (N=", summary(matched2$AC_type_noST)[2], ")"))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0.8)) + 
  labs(x = "Percentage of SCs in Constituency",
       y = "",
       title = "Before Matching") + 
  scale_y_continuous(limits = c(0, 0.1),
                     breaks = c(0, 0.02, 0.04, 0.06, 0.08, 0.1)) +
  scale_x_continuous(breaks = c(0, 10, 20, 30, 40, 50, 60)) 


# Second Plot: After Matching

ggplot() + 
  geom_density(aes(x = matched1$SC_percent71_true[matched1$AC_type_noST == "SC"], 
                   color = "Reserved")) + 
  geom_density(aes(x = matched1$SC_percent71_true[matched1$AC_type_noST == "GEN"],
                   color = "General"), 
               linetype = "dashed") +
  scale_color_manual(values = colors,
                   labels = c(paste0("General (N=" , summary(matched2$AC_type_noST)[1], ")"),
                              paste0("Reserved (N=", summary(matched2$AC_type_noST)[2], ")"))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0.8)) + 
  labs(x = "Percentage of SCs in Constituency",
       y = "",
       title = "After Matching") + 
  scale_y_continuous(limits = c(0, 0.1),
                     breaks = c(0, 0.02, 0.04, 0.06, 0.08, 0.1)) +
  scale_x_continuous(breaks = c(0, 10, 20, 30, 40, 50, 60)) 

# Third Plot: After Matching with Caliper

ggplot() + 
  geom_density(aes(x = matched2$SC_percent71_true[matched2$AC_type_noST == "SC"],
                   color = "Reserved")) + 
  geom_density(aes(x = matched2$SC_percent71_true[matched2$AC_type_noST == "GEN"],
                   color = "General"), 
               linetype = "dashed") +
  scale_color_manual(values = colors,
                   labels = c(paste0("General (N=" , summary(matched2$AC_type_noST)[1], ")"),
                              paste0("Reserved (N=", summary(matched2$AC_type_noST)[2], ")"))) +
  theme(plot.title = element_text(hjust = 0.5)) +
  theme(plot.title = element_text(face = "bold")) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.title = element_blank(), 
        legend.background = element_rect(fill = "white", color = "black", size = .5, linetype = "solid"),
        legend.justification = c(1, 0), legend.position = c(1, 0.8)) + 
  labs(x = "Percentage of SCs in Constituency",
       y = "",
       title = "After Matching with Caliper") + 
  scale_y_continuous(limits = c(0, 0.1),
                     breaks = c(0, 0.02, 0.04, 0.06, 0.08, 0.1)) +
  scale_x_continuous(breaks = c(0, 10, 20, 30, 40, 50, 60)) 

```

```{r table_3_setup}

# Generates a new matrix with row number equivalent to the number of outcome
# variables of interest

mymatrix <- matrix(nrow = length(outcomeindex), ncol = 12)

# for loop to run regressions and calculate standard errors begins
# Iterates once for each outcome variable of interest 

for(i in 2:length(outcomeindex)){

# Prepares both matched models for regression 
  
matched1_smaller <- matched1[complete.cases(matched1[outcomeindex[i]], matched1$AC_type_noST), ]
matched2_smaller <- matched2[complete.cases(matched2[outcomeindex[i]], matched2$AC_type_noST), ]

# Regresses outcome variable of interest on type of constituency

mymodel <- lm(matched1_smaller[, outcomeindex[i]] ~ matched1_smaller$AC_type_noST)

# Runs clusterSE() from earlier to calculate clustered standard errors

mySE <- clusterSE(mymodel, data = matched1_smaller, cluster = "State_no_2001_old")

# Outputs difference coefficient for all matches to the first column to prepare
# for the xtable() call

mymatrix[i, 1] <- round(mymodel$coef[2], 2)

# Intermediary steps - will be cleared before xtable()

mymatrix[i, 2] <- round(mymodel$coef[2] + qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)
mymatrix[i, 3] <- round(mymodel$coef[2] - qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)

# Outputs p-values for all matches to the second column to prepare for the
# xtable() call

mymatrix[i, 4] <- ifelse(coeftest(mymodel, mySE)[2, 4] < 0.01, "<0.01", 
                         round(coeftest(mymodel, mySE)[2, 4], 2))

# Repeating with caliper matching 

mymodel <- lm(matched2_smaller[, outcomeindex[i]] ~ matched2_smaller$AC_type_noST)

mySE <- clusterSE(mymodel, data = matched2_smaller, cluster = "State_no_2001_old")

# Outputs difference coefficient for caliper matches to the third column to
# prepare for the xtable() call

mymatrix[i, 5] <- round(mymodel$coef[2], 2)

# Intermediary steps - will be cleared before xtable()

mymatrix[i, 6] <- round(mymodel$coef[2] + qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)
mymatrix[i, 7] <- round(mymodel$coef[2] - qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)

# Outputs p-values for caliper matches to the fourth column to prepare for the
# xtable() call

mymatrix[i,8] <- ifelse(coeftest(mymodel, mySE)[2, 4] < 0.01, "<0.01", 
                        round(coeftest(mymodel, mySE)[2, 4], 2))

# Adding in bias adjustment

SCpop <- matched2_smaller$SC_pop71_true
mymodel <- lm(matched2_smaller[, outcomeindex[i]] ~ matched2_smaller$AC_type_noST + SCpop)

# Clusters SEs at state level 

mySE <- clusterSE(mymodel, data = matched2_smaller, cluster = "State_no_2001_old")

# Outputs difference coefficient for bias-adjusted matches to the fifth column
# to prepare for the xtable() call

mymatrix[i, 9] <- round(mymodel$coef[2], 2)

# Intermediary steps - will be cleared before xtable()

mymatrix[i, 10] <- round(mymodel$coef[2] + qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)
mymatrix[i, 11] <- round(mymodel$coef[2] - qnorm(.975) * coeftest(mymodel, mySE)[2, 2], 2)

# Outputs p-values for bias-adjusted matches to the sixth column to prepare for
# the xtable() call

mymatrix[i, 12] <- ifelse(coeftest(mymodel, mySE)[2, 4] < 0.01, "<0.01", 
                          round(coeftest(mymodel, mySE)[2, 4], 2))

# regression for loop ends

}	

# Setting the row and column names to prepare for the xtable() call
	
row.names(mymatrix) <- names(devDTA[outcomeindex])
colnames(mymatrix) <- c("Difference", "Conf.int min", "Conf.int max", "P-value", "Difference", 
                        "Conf.int min", "Conf.int max", "P-value", "Difference", "Conf.int min", 
                        "Conf.int max", "P-value")

row.names(mymatrix) <- c("Percentage SCs", "Literacy rate ", "Employment rate ", 
                         "Agricultural laborers", "Electricity in village", "School in village ",
                         "Medical facility in village","Comm. channel in village", "Literacy gap", 
                         "Employment gap", "Agricultural laborers gap", 
                         "Electricity in village gap", "School in village gap",
                         "Medical facility in village gap","Comm. channel in village gap")

# Subsetting matrix that will go on to make the coefficient figure below

figurematrix <- mymatrix[-1, -c(1:4)]

# Subsetting matrix that will be exported through xtable()

articlematrix <- mymatrix[-1, c(1, 4, NA, 5, 8, NA, 9, 12)]

articlematrix_output <- xtable(articlematrix)

```

```{r table_3, results = "asis"}

print(articlematrix_output)

```

```{r figure_4}

# Setting margins for the forthcoming figure

par(mar = c(4, 12, 1, .5))

# Plotting coefficient differences for the matching estimate and bias-adjusted
# estimate

plot(x = NULL,axes = F, xlim = c(-10, 10), ylim = c(1,14), 
     xlab = "Difference in percentage points in 2001 (SC-GEN)", ylab = "", cex.main = 2)

abline(v = 0, lty = 3)
axis(side = 1,tick = TRUE, las = 1, cex.axis = 1)
axis(side = 2,at = c(14:1), labels = row.names(figurematrix), cex.axis = 1, las = 1, tick = F)

# This demonstrates the change in coefficients between the matching estimate and
# bias-adjusted estimate in some form, however I'm having trouble getting it to
# output

for (i in 1:nrow(figurematrix)) {
arrows(x0 = as.numeric(figurematrix[i, 2]), x1 = as.numeric(figurematrix[i, 3]), 
       y0 = (15 - i + .1), y1 = (15 - i + .1), angle = 90, length = .025, code = 3)

arrows(x0 = as.numeric(figurematrix[i, 6]), x1 = as.numeric(figurematrix[i, 7]), 
       y0 = (15 - i - .1), y1 = (15 - i - .1), angle = 90, length = .025, code = 3)

points(x = as.numeric(figurematrix[i, 1]), y = 15 - i + .1, pch = 19, cex = .7)

points(x = as.numeric(figurematrix[i, 5]), y = 15 - i - .1, pch = 1, cex = .7, col = "gray40")
text(x = 95, y = i, figurematrix[i, 4], cex = .8)

}
legend(x = 2.2, y = 4, pch = c(19, 1, NA), lty = c(NA, NA, 1), 
       legend = c("Matching est.", "Bias-adjusted est.", "95% conf. interval"), 
       cex = .9, bg = "white", merge = T)
dev.off()

```

```{r table_4}

# Outputting variables from matched2 into their own vectors for clearer
# interpretation in the forthcoming regressions

# This section explores the interaction effects with the percentage of Scheduled
# Caste individuals in the community, with a particular intent to identify if
# there is an interaction effect between percent SC and the type of constituency

PropSC <- matched2$SC_percent71_true 
educ_lag <- matched2$Plit71_SC
worker_lag <- matched2$P_W71_SC 
agr_lag <- matched2$P_al71_SC
stateFE <- as.factor(matched2$State_no_2001_old)

# In this section two distinct regression models are employed for each outcome
# variable of interest

# Model 1 regresses on the type of constituency, the proportion of Scheduled
# Caste individuals, and the interaction effect of the two

# Model 2 includes all of the explanatory variables from Model 1, in addition to
# the baseline value of the outcome variable of interest and a state fixed
# effect

# Regressing Scheduled Caste literacy rate

# Model 1 

model1lm <- lm(matched2$Plit_SC_7 ~ matched2$AC_type_noST * PropSC)

# Model 2 

model3lm <- lm(matched2$Plit_SC_7 ~ educ_lag + matched2$AC_type_noST * PropSC + stateFE)

# Regressing Scheduled Caste employment rate 

# Model 1 

model4lm <- lm(matched2$P_W_SC ~ matched2$AC_type_noST * PropSC)

# Model 2 

model6lm <- lm(matched2$P_W_SC ~ worker_lag + matched2$AC_type_noST * PropSC + stateFE)

# Regressing Scheduled Caste agricultural labor share 

# Model 1 

model7lm <- lm(matched2$P_al_SC ~ matched2$AC_type_noST * PropSC)

# Model 2 

model9lm <- lm(matched2$P_al_SC ~ agr_lag + matched2$AC_type_noST * PropSC + stateFE)

# Outputting regression results for internal check - vestigial

summary(model1lm)
summary(model3lm)
summary(model4lm)
summary(model6lm)
summary(model7lm)
summary(model9lm)

# Estimating standardized errors clustered at the state level

model1lm$se <- clusterSE(model1lm, data = matched2, cluster = "State_no_2001_old")
model3lm$se <- clusterSE(model3lm, data = matched2, cluster = "State_no_2001_old")
model4lm$se <- clusterSE(model4lm, data = matched2, cluster = "State_no_2001_old")
model6lm$se <- clusterSE(model6lm, data = matched2, cluster = "State_no_2001_old")
model7lm$se <- clusterSE(model7lm, data = matched2, cluster = "State_no_2001_old")
model9lm$se <- clusterSE(model9lm, data = matched2, cluster = "State_no_2001_old")

# Outputting results into apsr table 

library(apsrtable)
table_OLS <- apsrtable(model1lm, model3lm, model4lm, model6lm, model7lm, model9lm, 
                       se = "robust", omitcoef = c(6:19),  
                       coef.names = c("Intercept", "SC reserved", "Percentage SC", 
                                      "SC reserved * Percentage SC", "Literacy SC in 1971", 
                                      "Worker SC in 1971", "Agr. laborer SC in 1971"))

# Printing table 

#Table 4
table_OLS
```

```{r table_5}


# This section explores the possibility that there is no visible effect on net
# development because quota-elected politicians shift resources from high
# Scheduled Caste density areas to low density areas. It does so by attempting
# to predict various development indicators, namely whether or not a village was
# electrified, has a primary school, has a medical facility, and has a
# communication channel, using an interaction model effect with type of
# constituency and proportion of Scheduled Caste individuals

#load full village dataset
load("replication_files/Vill_AC.RData")

# Checking data - vestigial 

dim(vill_con) 
names(vill_con)

vill_con$VD01_state_id <- as.numeric(as.character(vill_con$VD01_state_id))
summary(vill_con$VD01_state_id)
summary(vill_con$VD01_AC_id)
summary(matched2$State_number_2001)
summary(matched2$AC_no_2001)

# Only using villages that correspond to Assembly Constituencies from the quota
# dataset

##reducde to ACs that are in matched2
vill <- merge(vill_con, matched2[, c(1:2, 28)], by.x = c("VD01_state_id", "VD01_AC_id"), 
              by.y = c("State_number_2001", "AC_no_2001"))

# Vestigial check 

names(vill)
dim(vill)

# Preparing variables for regression

PropSC_vill <- (as.numeric(as.character(vill$VD01_sc_p)) / as.numeric(as.character(vill$VD01_t_p)))
states <- as.factor(vill$VD01_state_id)

# Regressing outcome variables of interest on the interaction of type of
# constituency and proportion Scheduled Caste and the state fixed effects

# Electricity

model1glm <- glm(vill$VD01_power_supl ~ vill$AC_type_noST * PropSC_vill + 
                   as.factor(vill$VD01_state_id), family = binomial(link = "logit"))

# Primary School

model2glm <- glm(vill$VD01_educ ~ vill$AC_type_noST * PropSC_vill + 
                   as.factor(vill$VD01_state_id), family = binomial(link = "logit"))

# Medical Facility

model3glm <- glm(vill$VD01_medic ~ vill$AC_type_noST * PropSC_vill +
                   as.factor(vill$VD01_state_id), family = binomial(link = "logit"))

# Communication Channel

model4glm <- glm(vill$VD01_comm ~ vill$AC_type_noST * PropSC_vill +
                   as.factor(vill$VD01_state_id), family = binomial(link = "logit"))

##Try to cluster errors by AC, district, and state
#SEs clustered at state level. Remove # to check clustered at other levels
#cluster<-"VD01_uniqueAC"
#vill$VD01_district_unique<-paste(vill$VD01_state_id, "-", vill$VD01_district_id, sep="")
#cluster<-"VD01_district_unique"

# Calculating standard errors clustered at the state level 

cluster <- "VD01_state_id"

model1glm$se <- clusterSE(model1glm, data = vill, cluster = cluster)
model2glm$se <- clusterSE(model2glm, data = vill, cluster = cluster)
model3glm$se <- clusterSE(model3glm, data = vill, cluster = cluster)
model4glm$se <- clusterSE(model4glm, data = vill, cluster = cluster)

# Outputting results into apsr table 

library(apsrtable)
table_logit <- apsrtable(model1glm, model2glm, model3glm, model4glm, se = "both", 
                         stars = 1, omitcoef = c(4:19), 
                         coef.names = c("Intercept", "SC reserved", "Proportion SC", 
                                        "SC reserved * Proportion SC"))

# Printing table 

##Table 5
table_logit

```

# References